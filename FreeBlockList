/**
 * 
 */

import java.util.List;

/**
 * 
 */
public class FreeBlockList {
    
    private SinglyLinkedList<SinglyLinkedList> freeBlocks;
    
    
    public FreeBlockList(int size) {
        
        double x = Math.log10(size) / Math.log10(2);
        int listSize = (int) x;
        
        this.freeBlocks = new SinglyLinkedList<SinglyLinkedList>();
  
        
        //creates a list of singly linked lists
        //got the singly linked list code from project 5 in 2114 
        for (int i = 0; i < listSize; i++) {
            freeBlocks.add(i, new SinglyLinkedList<Handle>());
        }
                                     
    }
    
    //allocates freespace from the appropriate spot in the list
    //based on the size of the byte of data
    public Handle allocateBlock(int size) {
        //find the starting position of the data in the freeBlockList
        int startPos = findStartPos(size);
        
        //create the handle
        Handle newHandle = new Handle(startPos + findBestIndex(size), size);
        
        //allocate the free space from the freeBlockList
       
        
        //return it to the memory manager
        return newHandle;
        
    }
    
    private int findStartPos(int size) {
        //find the corresponding index
        int index = findBestIndex(size);
        
        //find how big the specific linkedlist is
        int count = freeBlocks.get(index).size();
    
        //calculate the start position by multipling the index of the
        //data by how much data is in the list
        return index * count;
    }
    
    //adds free space back into the appropriate spot
    public void releaseBlock(Handle memHandle) {
        
        int size = memHandle.getLength();
        
        //extract the starting position from the handle
        int index = findBestIndex(size);
        int startPos = findStartPos(size);
  
        //go to the right spot in freeBlocks
        //add the block of data

        
    }
    
    //finds the smallest power of 2 that is greater than or equal to size
    private int findBestIndex(int size) {
        
        double x = Math.log10(size) / Math.log10(2);
        int index = (int) x;
        
        return index;
    }
    
    //Finds and allocates a block with the specified size. 
    //If an exact match is not found, it tries to split a larger block
    private Byte findAndAllocateBestFitBlock(int size, int allSize) {

        
    }
    
    //merges adjacent free blocks when possible
    public void mergeFreeBlocks() {
        
    }
    
    public void dump() {
        
    }
    
    
    
    
    

}
