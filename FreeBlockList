
/**
 * 
 */

/**
 * 
 */
public class FreeBlockList {
    // FreeBlock help = new FreeBlock(0, 0);
    // private FreeBlock loveSosa;
    private SinglyLinkedList<SinglyLinkedList<FreeBlock>> freeBlocks;

    public FreeBlockList(int size) {

        double x = Math.log10(size) / Math.log10(2);
        int listSize = (int)x;

        this.freeBlocks = new SinglyLinkedList<SinglyLinkedList<FreeBlock>>();

        // creates a list of singly linked lists
        // got the singly linked list code from project 5 in 2114
        for (int i = 0; i < listSize; i++) {
            
            freeBlocks.add(i, new SinglyLinkedList<FreeBlock>());
        }
        FreeBlock intializer = new FreeBlock(0, (int)Math.pow(2, listSize));
        freeBlocks.get(listSize - 1).add(intializer);

    }

    private int findStartPos(int size) {
        
        // find the starting position of the data in the freeBlockList
        int indexPos = findBestIndex(size);
        
        //get the size of the index list 
        int multiple = freeBlocks.get(indexPos - 1).size();
        
        //get the size of the byte
        int byteSize = (int) Math.pow(2, indexPos);
        
        //multiply the size of the byte by how many items 
        //are in the list
        int result = multiple * byteSize;
        
        return result;
    }


    // allocates freespace from the appropriate spot in the list
    // based on the size of the byte of data
    public Handle createHandle(int size) {
        
        int result = findStartPos(size);
     
        Handle newHandle = new Handle(result, size);

        // return it to the memory manager
        return newHandle;

    }
    
    // adds free space back into the appropriate spot
    public void releaseBlock(Handle memHandle) {

        int size = memHandle.getLength();

        // extract the starting position from the handle
        int index = findBestIndex(size) - 1;
        
        int start = findStartPos(size);

        // go to the right spot in freeBlocks
        // add the block of data
        FreeBlock block = new FreeBlock(start, size);
        freeBlocks.get(index).add(block);

    }


    public void addBlock(int size) {

        int bestIndex = findBestIndex(size) - 1;

        int nextHighest = findNextHighest(bestIndex);
        
        if (nextHighest == -1) {
            doubleList();
            nextHighest = findNextHighest(bestIndex);
        }
        //System.out.println("this is the best Index" + bestIndex);
        //System.out.println("this is the next highest" + nextHighest);

        while (nextHighest != bestIndex) {

            split(nextHighest);
            nextHighest--;
        }
        freeBlocks.get(bestIndex).remove(0);

    }


    private void split(int index) {

        int currIndex = index;
        int lowerIndex = index - 1;

 
        int multiple = freeBlocks.get(lowerIndex).size();
        int newSize = (int)Math.pow(2, lowerIndex);
      
        int position = multiple * newSize;

        // create two blocks of index i-1
        FreeBlock firstSplit = new FreeBlock(position, newSize);
        FreeBlock secondSplit = new FreeBlock(position + newSize, newSize);

        // add the two blocks to the lower index i -1
        freeBlocks.get(lowerIndex).add(firstSplit);
        freeBlocks.get(lowerIndex).add(secondSplit);

        // remove the last block off of the index
        freeBlocks.get(currIndex).remove(0);

    }
    
    // finds the next highest index that isn't null
    private int findNextHighest(int best) {
        int nextHighest = best;
        for (int x = nextHighest; x < freeBlocks.size(); x++) {
           
            if (freeBlocks.get(x).size() > 0) {

                return x;
            }
        }
        
        if(freeBlocks.get(nextHighest).size() == 0) {
            return -1;
        }
        return nextHighest;
    }

    // finds the smallest power of 2 that is greater than or equal to size
    private int findBestIndex(int size) {

        double x = Math.log10(size) / Math.log10(2);
        int index = (int)x;
        return index;
    }


    public void doubleList() {
        
       // System.out.println("doubling the freeblocklist");
        
        int newIndex = freeBlocks.size();
        
        SinglyLinkedList<FreeBlock> list = new SinglyLinkedList<FreeBlock>();
        
        FreeBlock freshBlock = new FreeBlock(0, (int)Math.pow(2,
            newIndex));
        
        list.add(freshBlock);
        
        freeBlocks.add(newIndex, list);

        //mergeFreeBlocks();
    }


    // merges adjacent free blocks when possible
    public void mergeFreeBlocks() {

        // continue until you reach the end of the freeBlocks list
        for (int i = 0; i < freeBlocks.size(); i++) {
            
            for (int j = 0; j < freeBlocks.get(i).size() - 1; i++) {
                
                if (freeBlocks.get(i).size() > 1) {
                    FreeBlock curr = freeBlocks.get(i).get(j);
                    FreeBlock next = freeBlocks.get(i).get(j + 1);
                    
                    int currStart = curr.getPos();
                    int nextStart = next.getPos();
                    int blockSize = curr.getSize();
                    
                    int startPos = findStartPos(blockSize * 2);
                    FreeBlock newBlock = new FreeBlock(startPos, blockSize * 2);
                    
                    if ((currStart | blockSize) == (nextStart | blockSize)) {
                        freeBlocks.get(i + 1).add(newBlock);
                        
                    }
                    
                }
            }

        }

    }


    private boolean isEmpty() {

        int count = 0;

        for (int i = 0; i < freeBlocks.size(); i++) {
            if (freeBlocks.get(i).isEmpty()) {
                count++;
            }
        }

        if (count == freeBlocks.size()) {
            return true;
        }

        return false;

    }


    public void dump() {

        for (int x = 0; x < freeBlocks.size(); x++) {

            if (freeBlocks.get(x).size() > 0) {
                int power = (int) Math.pow(2, x + 1);
                System.out.print(power + ": ");
                for (int y = 0; y < freeBlocks.get(x).size(); y++) {
                    System.out.print("" + freeBlocks.get(x).get(y).getSize() + " ");

                }
                System.out.println("");
            }

        }

        if (isEmpty()) {
            System.out.println("There are no freeblocks in the memory pool");
        }

    }

}
